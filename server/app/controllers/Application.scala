package controllers

import javax.inject._

import play.api.mvc._
import play.api.libs.json._
import akka.actor.Actor
import play.api.libs.streams.ActorFlow
import akka.actor.ActorSystem
import akka.stream.Materializer

import play.api.db.slick.DatabaseConfigProvider
import play.api.db.slick.HasDatabaseConfigProvider
import slick.jdbc.JdbcProfile
import slick.jdbc.JdbcCapabilities
import slick.jdbc.PostgresProfile.api._
import models.OCDatabaseModel
import scala.concurrent.ExecutionContext

import onlineclassroom._
import onlineclassroom.ReadsAndWrites._
import scala.concurrent.Future

@Singleton
class Application @Inject()(protected val dbConfigProvider: DatabaseConfigProvider, cc: ControllerComponents)(implicit ec: ExecutionContext) 
    extends AbstractController(cc) with HasDatabaseConfigProvider[JdbcProfile] {
  
  val model = new OCDatabaseModel(db)
  model.initializeIfNeeded()

  def index = Action { implicit request =>
    Ok(views.html.index()) 
  }

  /**
    * This method is removes the boilerplate that is associated with pulling data out of a post request.
    *
    * @param f The function that is executed with the body to build the response.
    * @param request The request containing the body.
    * @param reads An implicit converter from Json.
    * @return A future of a result that is generated by the function or a redirect to the initial page.
    */
  def withJsonBody[A](f: A => Future[Result])(implicit request: Request[AnyContent], reads: Reads[A]): Future[Result] = {
    request.body.asJson.map { body =>
      Json.fromJson[A](body) match {
        case JsSuccess(a, path) => f(a)
        case e @ JsError(_) => Future(Redirect(routes.Application.index()))
      }
    }.getOrElse(Future(Redirect(routes.Application.index())))
  }

  def tryLogin = Action.async { implicit request =>
    withJsonBody[LoginData] { li =>
      model.validateUser(li.username, li.password).flatMap { uid => 
        uid match {
          case None =>
            Future(Ok(Json.toJson(UserData(li.username, -1, scala.util.Random.nextInt()))))
          case Some(n) =>
            Future(Ok(Json.toJson(UserData(li.username, n, scala.util.Random.nextInt()))))
            // val instructorCourses = model.instructorCourseIds(n, db)
            // instructorCourses.map(_ match {
            //   case Seq() =>
            //     val ud = UserData(li.username, uid, scala.util.Random.nextInt(), false)
            //     Ok(Json.toJson(ud)).withSession(request.session + ("username" -> li.username) + ("userid" -> n.toString))
            //   case _ =>
            //     val ud = UserData(li.username, uid, scala.util.Random.nextInt(), true)
            //     Ok(Json.toJson(ud)).withSession(request.session + ("username" -> li.username) + ("userid" -> n.toString) + ("instructor" -> "yes"))
            // })
        }
      }
    }
  }
}
